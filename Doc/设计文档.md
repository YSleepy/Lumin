# 🎮 游戏引擎设计初探

在现代游戏引擎的架构中，**游戏线程（Game Thread）** 与 **渲染线程（Render Thread）** 的分离，是提升性能与流畅度的核心设计之一。通过让渲染线程独立运行，游戏逻辑帧率（如物理更新）与渲染帧率可以有效解耦，实现更平滑的画面体验。

---

## 🧵 线程职责划分

### 🔹 游戏线程（Game Thread）
- 负责处理游戏逻辑：物理更新、AI、输入处理、事件系统等。
- 通常采用固定时间步长，以保证逻辑稳定性（如 60 Hz）。

### 🔹 渲染线程（Render Thread）
- 仅负责图形渲染，将游戏状态以尽可能高的频率呈现出来。
- 独立于游戏逻辑帧率，可以实现如 144 Hz、240 Hz 的流畅输出。
- 保证避免在渲染过程中被逻辑计算阻塞。

---

## 🖼️ Qt + OpenGL 架构选型

本项目基于以下分工：

- **Qt**：负责窗口管理、输入系统、事件循环
- **OpenGL**：负责底层渲染管线

与 GLFW 不同，Qt 并未提供类似 `glfwInit()` 的全局 OpenGL 初始化接口，因此需要自行构建一个 **OpenGL 函数管理类**，用于加载、管理所有 OpenGL 函数指针。
当然也可以选择每个类使用OpenGL时都初始化。这里就选择第一种了！

---

## 🔧 OpenGL 函数管理类

通过封装的函数管理类，你可以在任何地方像这样调用 OpenGL API：

```cpp
L_GL.glAttachShader(m_programID, vertexShader);
```

## 📖 参考文献

<a href = https://zhouqijie.github.io/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84/EX%20-%20OpenGL/%E8%A1%A5%E5%85%85%EF%BC%9A%E7%8A%B6%E6%80%81%E6%9C%BA%E5%92%8C%E4%B8%8A%E4%B8%8B%E6%96%87.html>状态机和上下文</a>


